# 인터럽트(Interrupt)

## 1. Interrupt

### 1-1. 정의

* 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 역할

* 지금 수행 중인 일보다 더 중요한일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야 한다.

* **비동기적으로 발생하는 주변 장치의 서비스 요청에 CPU가 가장 빠르게 대응할 수 있는 방법**

* 인터럽트는 크게  `내부 인터럽트`,`외부 인터럽트`, `소프트웨어 인터럽트` 로 나눌 수 있다.

  * **내부 인터럽트**

    * **CPU 내부의 하드웨어 신호에 의해 발생**

    * `Trap`이라고 불리며, 잘못된 명령이나 데이터를 사용할 때 발생하는 인터럽트

      * CPU가 어떤 명령을 수행하려고 하는데 그 명령이 수행할 수 없는 명령인 경우 CPU는 자기 자신한테 인터럽트를 건다. 이를 Exception 이라고 한다.

    * **Division by 0 , Overflow, Exception**

      

  

  * **외부 인터럽트**

    * **CPU의 외부 하드웨어 신호에 의해 발생**

    * 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 인해 발생하는 인터럽트

    * **전원 이상** : 정전, 파워 이상 등

      * 파워 공급에 이상이 생기면 이를 감지하고 인터럽트를 보내어 갑자기 전원이 꺼져 메모리가 날라가는 불상사를 막아준다.

    * **기계이상**

    * **입출력**

      * I/O 장치들로부터 발생하는 인터럽트  

    * **타이머**

      * CPU 스케줄링과 관련
      *  타이머가 CPU에게  주기적으로 인터럽트를 보내준다.

      

  * **소프트웨어 인터럽트**

    * **명령어의 수행에 의해 발생**
    * **SVC (Suprevisor Call)** ( = system call )
      * SVC는 프로세서 명령어를 수행 시에  프로세서가 운영체제를 관리감독하는 프로그램(supervisor)에게 제어권을 넘겨서 해결하는 것을 말한다.
      * 사용자가 프로그램을 실행 시키거나 감시프로그램을 호출하는 동작을 수행하는 경우
      * 복잡한 입출력을 처리하는 경우
      * 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.



* **인터럽트 우선순위**
  * 전원 이상 > 기계착오 > 외부 신호 > 입출력 > 명령어 잘못 > 프로그램 검사 > SVC
  * 일반적으로 **하드웨어 인터럽트(내부,외부 인터럽트) > 소프트웨어 인터럽트**이고 **외부 인터럽트 > 내부 인터럽트**



### 1-2. 인터럽트가 왜 필요할까?

* 주 프로그램이 실행되다가 인터럽트가 발생하면 현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC등을 스택에 잠시 저장한 뒤에 `인터럽트 서비스 루틴`으로 간다.

  

* 만약 인터럽트가 없다면?

  * CPU는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 `폴링(Polling)` 이라 한다.)

    * 예를 들어 입출력 이벤트가 시작되었는지 또는 끝났는지를 계속해서 체크를 해야 한다.

      

* 컨트롤러가 입력을 받아들이는 방법(**우선순위 판별방법**)에는 `폴링 방식` 과 `인터럽트 방식` 이 있다.

  * **폴링 방식(Polling)** - S/W 적인 방법

    * 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식

    * 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.

      * 속도가 빠른 장치에 높은 등급을 부여 한다.

    * 우선순위 변경이 쉽다. 👍

    * 회로가 간단하고 융통성이 있으며, 별도의 하드웨어가 필요 없다 👍

    * 많은 인터럽트가 있을 경우 하드웨어적인 방법에 비해 우선순위 판단 속도가 느리다. 😭

    * Polling 주기가 짧으면 서버 성능에 부담이 생기며, 주기가 길어지면 실시간성이 떨어진다. 😭

      

  * **인터럽트 방식(Vectored Interrupt)** - H/W 적인 방법

    * 인터럽트를 요청할 수 있는 장치와 CPU 사이에 장치번호를 식별할 수 있는 버스를 직렬/병렬로 연결한다.
    * 인터럽트 백터는 **인터럽트를 발생한 장치가 분기할 곳에 대한 정보**이다.
    * 소프트웨어 적인 방법에 비해 비경제적이다 😭
    * 회로가 복잡하고 융통성이 없다. 😭
    * 별도의 소프트웨어가 필요 없이 하드웨어로 처리되므로 속도가 빠르다.👍

    

  * 인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속한 대응이 가능하다. 따라서 **실시간 대응**이 필요할 때 필수적인 기능이다.

  * 즉 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법이다.**





## 2. I/O Operation Handling

### 2-1. Computer System Operation

<img width="648" alt="image" src="https://user-images.githubusercontent.com/68215452/133606325-25e3db3c-775b-4586-a702-101fb033781d.png">





* 각 **Device Controller(DC)** 는 특정 장치 유형을 담당한다.

* 각 DC는 **local buffer**를 갖는다.

  * DC는 장치와 로컬 버퍼간의 데이터를 전송할 수 있다.

* 입출력(I/O)은 디바이스에서 로컬버퍼에서 디바이스로 디바이스에서 로컬버퍼로 전송된다.

* 메인 메모리와 로컬 버퍼 사이의 데이터 전송은 CPU가 담당한다.

  * 각 **Device Driver**가 OS와 DC간의 통신을 돕는다.

    * 커널에 위치해 있다.

    * Device Driver는 컨트롤러와 커널사이의 균일한 인터페이스를 제공함으로서 DC의 기능을 추상화해준다.

    * DC는 I/O 작업이 끝났음을 Device Driver에 알린다.

      

### 2-2. Programmed I/O (a.k.a polling)

* CPU는 DC를 통해서 **I/O 장치의 상태를 반복적으로 점검**

  * 장치가 I/O 작업을 수행할 준비가 되었는지? 요청된 I/O 작업이 완료 되었는지?

* 상태가 준비되면 CPU가 I/O 작업에 필요한 데이터를 직접 이동한다.

  * CPU는 항상 I/O 작업을 처리하는데 관여된다.

  * CPU가 I/O 장치가 준비되기를 기다리는 데 상당한 시간이 낭비되어(**busy waiting**) CPU 리소스가 비효율적으로 사용될 수 있다.

    

### 2-3. Interrupt-driven I/O

* DC가 인터럽트를 생성하여 CPU에 이벤트를 알린다!
  * I/O 장치에서 수신 요청이 도착할 때, I/O 작업이 끝났을 때



* 인터럽트 처리 프로세스

  <img width="314" alt="image" src="https://user-images.githubusercontent.com/68215452/133606343-fe1b37a1-32a3-4c16-ba22-3f58809ffc80.png">

  
  
  1. 인터럽트가 발생한다.
  2. 시스템은 CPU의 현재 상태를 저장한다.
     * 인터럽트 처리 후 현재 상태로 돌아오게 된다.
     * 레지스터들과 중단된 명령의 주소를 저장한다.
     * HW 또는 운영체제에서 수행
  3. 지정된 **인터럽트 서비스 루틴(ISR) 또는 인터럽트 핸들러로 이동**한다.
     * **인터럽트 백터**에 모든 서비스 루틴의 주소가 포함되어 있다.
  4. 레지스터들을 복원하여 마지막 상태로 되돌린다.



* CPU가 busy waiting을 할 필요가 없기 때문에 Programmed I/O(Polling) 보다 더 효율적이다.
* 하지만 대량의 데이터를 처리할 경우 CPU가 여전히 많은 부하를 받게된다.
  * DC와 main memory 사이의 데이터 전송을 CPU가 담당하기 때문



### 2-4. Direct Memory Access(DMA) I/O

* I/O 작업을 처리하기 위해 `DMA 컨트롤러` 라는 하드웨어를 사용한다.
  * CPU가 I/O 작업을 DMA 컨트롤러에게 요청한다.
  * DMA 컨트롤러가 **CPU 개입 없이 DC와 메인 메모리 간의 데이터 전송을 수행**한다.
  * DMA 컨트롤러가 인터럽트를 생성하여 CPU에게 작업이 완료되었음을 알린다.



* CPU는 I/O 작업이 처리되는 동안 다른 작업을 수행하고 있을 수 있다.
* High Speed I/O 장치에 사용되며 메모리 속도에 가까운 속도로 정보 전송에 사용된다.



* **DMA I/O : Read Operation**

  <img width="684" alt="image" src="https://user-images.githubusercontent.com/68215452/133606363-7bf73275-8cc6-4e34-95bd-c15c349aaffb.png">



* **DMA I/O : Write Operation**

  <img width="649" alt="image" src="https://user-images.githubusercontent.com/68215452/133606568-c9d2b2b6-cfed-4696-8b88-e3f2ec726381.png">
  
  

---

* 참고자료
  * 아주대학교 오상은 교수님 운영체제 강의자료
  * https://jhnyang.tistory.com/167
  * https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Interrupt.md
  * https://github.com/Songwonseok/CS-Study/blob/main/OS/Interrupt.md