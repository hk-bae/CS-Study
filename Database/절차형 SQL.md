# 절차형 SQL
### 절차형 SQL 이란?
절차형 SQL 은 C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행, 분기, 반복 등의 제어가 가능한 SQL 이다.
### 절차형 SQL의 특징
- 일반적인 프로그래밍 언어에 비해 효율은 떨어지지만, 단일 SQL 문장으로 처리하기 어려운 연속적인 작업들을 처리하는데 적합하다
   - 일반 프로그래밍 언어 + 여러번의 SQL VS 절차형 SQL?
- 절차형 SQL 은 DBMS 엔진에서 직접 실행되기 때문에, 입/출력 패킷이 적은 편이다.
- 절차형 SQL 을 활용하여 다양한 기능을 수행하는 저장 모듈을 생성할 수 있다.
- Block 구조로 이루어져 있다.
#### 절차형 SQL 의 아키텍쳐
![image](https://user-images.githubusercontent.com/62740151/138692109-902f9452-56b2-4fec-b823-d8d609976341.png)
<br>
https://geniusjo.tistory.com/entry/%EC%A0%88%EC%B0%A8%ED%98%95-SQL
<br>
1. PL/SQL Block 프로그램을 입력 받으면 SQL 문장과 프로그램 문장을 구분하여 처리한다
2. 프로그램 문장은 PL/SQL 엔진이 처리한다
3. SQL 문장은 ORACLE 서버의 SQL Statement Executor 가 실행한다.
## 절차형 SQL 의 종류
1. Stored Procedure : 특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행한다.
2. Trigger : 데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행된다.
3. UDF (User Defined Function) : 프로시저와 유사하게 SQL 을 사용하여 일련의 작업을 연속적으로 처리하며, 종료 시 예약어 Return 을 사용하여 처리 결과를 단일 값으로 반환한다.
### 1. Stored Procedure
#### SP의 특징
1. 여러 프로그램에서 호출하여 사용될 수 있다.
2. 시스템의 일일 마감 작업, 배치 작업등에 주로 사용되곤한다
#### Stored Procedure 구성
```sql
DECLARE (필수)
BEGIN (필수)
   * CONTROL
   * SQL
   * EXCEPTION
   * TRANSACTION
END (필수)
```
- DECLARE : SP 의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부이다.
- BEGIN / END : SP 의 시작과 종료를 의미한다.
- CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리된다.
- SQL : DML, DCL 이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행한다.
- EXCEPTION : BEGIN ~ END 안의 구문 실행시 예외가 발생하면 이를 처리하는 방법을 정의한다.
- TRANSACTION : 수행된 데이터 작업들을 DB 에 적용할지 취소할지를 결정하는 처리부이다.
#### Stored Procedure 명령어
1. SP 생성
```sql
CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)
[지역변수 선언]
BEGIN
  프로시저 BODY;
END;
```
- OR REPLACE : 동일한 프로시저 이름이 이미 존재하는 경우, 기존의 프로시저를 대체할 수 있다.
- 프로시저명 : 생성하려는 프로시저의 이름을 지정한다
- 파라미터 : 프로시저 파라미터로는 다음과 같은 것들이 올 수 있다.
   - IN : 호출 프로그램이 프로시저에게 값ㅅ을 전달할 때 지정한다
   - OUT : 프로시저가 호출 프로그램에게 값을 반환할 때 지정한다.
   - INOUT : 호출 프로그램이 프로시저에게 값을 전달하고, 프로시저 실행 후 호출 프로그램에 값을 반환할 때 지정한다.
   - 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정한다.
   - 자료형 : 변수의 자료형을 지정한다
- 프로시저 BODY
   - 프로시저의 코드를 기록하는 부분이다.
   - BEGIN에서 시작하여 END로 끝나며, BEGIN 과 END 사이에는 적어도 하나의 SQL 문이 있어야한다. 
2. SP 실행
```sql
EXECUTE 프로시저명;
```
```sql
EXEC 프로시저명;
```
```sql
CALL 프로시저명;
```
3. SP 제거
```sql
DROP PROCEDURE 프로시저명
```

#### SP VS 일반 쿼리
![image](https://user-images.githubusercontent.com/62740151/138698039-b213ebbf-06a8-437d-859e-c6e6b66bd7f0.png)
<br>
https://skollhati.tistory.com/1
<br>
캐싱 유지에서 차이가 생긴다.
<br>
stored procedure의 경우 procedure 자체가 수정되거나, 인덱스 통계가 재 빌드 되면 새로 컴파일을 수행하고 캐싱이 된다.
<br>
하지만 동적 쿼리 실행의 경우 쿼리문 전체가 동일하지 않는 이상 캐싱된 수행 계획을 사용하지 않기 때문에 항상 "처음 실행의" 과정을 거치게 된다.
그렇기 때문에 매개 변수가 변경된,반복적 실행 시, 캐싱된 수행 계획을 이용하는 저장 프로시저가 효율적이다.
#### Stored Procedure 의 장단점
##### 장점
1. 하나의 요청으로 여러 SQL문을 실행 시켜, 네트워크에 대한 부하를 줄일 수 있다.
2. 미리 구문 분석 및 내부 중간 코드로 변환을 끝내야 하므로 처리시간이 줄어든다.
3. 데이터베이스 트리거와 결합하여 복잡한 규칙에 의한 데이터의 참조 무결성 유지가 가능하게 된다.
4. JAVA 등의 호스트 언어와 SQL 문장이 확실하게 분리된 소스 코드이므로 SP 만의 교체를 통해 수정이 가능하므로 보수성이 뛰어나다.
5. Stored Procedure 가 참조하는 테이블의 접근을 제한할 수 있다.
##### 단점
1. 프로그래밍 언어 보다 성능이 떨어진다.
2. 데이터베이스 제품에 대해 설명하는 구문 규칙이 SQL/PSM 표준과의 호환성이 낮기 때문에 코드 자산으로 재사용성이 나쁘다.
3. 디버깅이 어렵다
4. DB 확장이 어렵다
5. 형상관리가 어렵다
#### 결론
## 2. TRIGGER
트리거는 테이블에 대한 이벤트에 반응하여 자동으로 실행되는 작업을 의미한다.
트리거는 DML의 데이터 상태 관리를 자동화하는데 사용된다.
- 유의 사항
DBMS 벤더마다 다르지만, 테이블 마다 트리거의 개수를 제한하고 있다.
   - 각 테이블의 insert, delete, update 에 대해 하나의 트리거만 가지는 것이 좋다고 한다.
      - 테이블 마다인지 컬럼마다 인지 확인 필요
### TRIGGER 의 구성
```sql
DECLARE (필수)
EVENT (필수)
BEGIN (필수)
   * CONTROL
   * SQL
   * EXCEPTION
END (필수)
```
- EVENT : 트리거가 실행되는 조건을 명시한다.
### TRIGGER 명령어
1. TRIGGER 생성
```sql
CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명
[REFERENCING NEW | OLD AS 테이블명]
[FOR EACH ROW [WHEN 조건식]]
BEGIN
  트리거 BODY;
END;
```
- 동작시기 : 트리거가 실행될 때를 지정한다
   - AFTER : 테이블이 변경된 후에 트리거가 실행된다
   - BEFORE : 테이블이 변경되기 전에 트리거가 실행된다
- 동작 : 트리거가 실행되게 할 작업의 종류를 지정한다. [INSERT, DELETE, UPDATE]
- NEW | OLD : 트리거가 적영될 테이블의 별칭을 지정한다
   - NEW : 추가되거나 수정에 참여할 튜플들의 집합(테이블을)을 의미한다.
   - OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미한다.
- WHEN 조건식 : 트리거를 적용할 튜플의 조건을 지정한다
2. TRIGGER 제거
```sql
DROP TRIGGER 트리거명;
```
### TRIGGER 의 장단점
#### TRIGGER 장점
1. 데이터의 무결성 강화(참조 무결성)
2. 업무 처리 자동화
   - 트리거를 사용하면 트랜잭션에 의해 자동으로 다른 명령을 일으킴으로써 업무 처리를 자동화 할 수 있다.
   - 중간에 사용자가 개입하지 않고 구현된 규칙대로 알아서 실행된다.
#### TRIGGER 단점
1. 성능 하락
   - 특정 쿼리나 트랜잭션 마다 트리거를 발생시키는 이벤트에 포함되는지 검사하기 위해 쿼리 수행마다 트리거를 확인하는 작업을 수행한다.
2. 트랜잭션의 일부이기 때문에 작업이 진행되는 동안 계쏙 잠금 상태가 지속되어 외부로부터 block 상태가 된다.
3. 디버깅이 어렵다.
### TRIGGER 대체
1. 제약 조건 사용
   - TRIGGER 에서 가장 많은 시간을 소요하는 작업이 참조 연산이다, 이를 제약 조건을 사용하여 처리하면 성능 개선이 가능하다.
## 3. UDF (User Defined Function) 사용자 정의 함수
### 사용자 정의 함수의 특징
- 데이터베이스에 저장되어 DML 문의 호출에 의해 실행된다.
- RETURN 을 통해 값을 반환하기 때문에 출력 파라미터가 없다.
- INSERT, DELETE, UPDATE를 통한 테이블 조작은 할 수 없고 SELECT 를 통한 조회만 할 수 있다.
- 프로시저를 호출하여 사용할 수 없다.
- SUM(), AVG() 등의 내장 함수 처럼 DML 문에서 반환값을 활용하기 위한 용도로 사용된다.
### 사용자 정의 함수의 구성
```sql
DECLARE (필수)
BEGIN (필수)
  * CONTROL
  * SQL
  * EXCEPTION
  * RETURN (필수)
END (필수)
```
- RETURN : 호출 프로그램에 반환할 값이나 변수를 정의한다
### 사용자 정의 함수 명령어
1. 사용자 정의 함수 생성
```sql
CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
[지역변수 선언]
BEGIN
  사용자 정의 함수 BODY;
  RETURN 반환 값;
END;
```
2. 사용자 정의 함수 실행
사용자 정의 함수는 DML에서 속성명이나 값이 놓일 자리를 대체하여 사용된다.
```sql
SELECT 사용자 정의 함수명 FROM 테이블명;
INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명)
DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명;
UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;
```
3. 사용자 정의 함수 제거
```sql
DROP FUNCTION 사용자 정의 함수명;
```
## UDF 가 사용되는 곳
